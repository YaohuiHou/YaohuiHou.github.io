(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{355:function(e,t,a){"use strict";a.r(t);var r=a(1),s=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"websocket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#websocket","aria-hidden":"true"}},[e._v("#")]),e._v(" WebSocket")]),a("h2",{attrs:{id:"websocket-的引入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#websocket-的引入","aria-hidden":"true"}},[e._v("#")]),e._v(" WebSocket 的引入")]),a("h3",{attrs:{id:"背景分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景分析","aria-hidden":"true"}},[e._v("#")]),e._v(" 背景分析")]),a("p",[e._v("HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。")]),a("p",[e._v("当用户在浏览器上进行操作时，可以请求服务器上的api；但是反过来却不可能：服务器端发生了一个事件，无法将这个事件的信息"),a("strong",[e._v("实时主动")]),e._v("地通知客户端。只有在客户端查询服务器当前状态时，所发生事件的信息才会从服务器传递到客户端。")]),a("p",[e._v("那怎么去实时地知道服务器的状态呢？方法有两个：")]),a("p",[e._v("（1）"),a("strong",[e._v("轮询")]),e._v("：客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。")]),a("p",[e._v("（2）"),a("strong",[e._v("长连接")]),e._v("：客户端只请求一次，但是服务器会将连接保持，不会返回结果。当服务器有了新数据时，实时地发给客户端，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。")]),a("h3",{attrs:{id:"websocket-协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#websocket-协议","aria-hidden":"true"}},[e._v("#")]),e._v(" WebSocket 协议")]),a("p",[e._v("最新的 HTML5协议，制定了 WebSocket 协议标准，允许客户端和服务器端以"),a("strong",[e._v("全双工")]),e._v("的方式进行通信。")]),a("p",[e._v("WebSocket 的原理非常简单：利用HTTP请求产生握手，HTTP头部含有 WebSocket 协议的请求，*"),a("em",[e._v("握手之后，二者转用TCP协议进行交流")]),e._v("（QQ的协议）。")]),a("p",[e._v("WebSocket协议需要浏览器和服务器都支持才可以使用：")]),a("ul",[a("li",[a("p",[e._v("支持WebSocket协议的浏览器有：Chrome 4、火狐4、IE10、Safari5")])]),a("li",[a("p",[e._v("支持WebSocket协议的服务器有：Node 0、Apach7.0.2、Nginx1.3")])])]),a("h3",{attrs:{id:"http-长连接和-websocket-的长连接区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-长连接和-websocket-的长连接区别","aria-hidden":"true"}},[e._v("#")]),e._v(" http 长连接和 websocket 的长连接区别")]),a("p",[e._v("HTTP1.1通过使用Connection:keep-alive进行长连接，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。")]),a("p",[e._v("websocket是一个真正的全双工。长连接第一次tcp链路建立之后，后续数据可以双方都进行发送，"),a("strong",[e._v("不需要发送请求头")]),e._v("。")]),a("p",[e._v("keep-alive双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。")]),a("h3",{attrs:{id:"socket-io-的引入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socket-io-的引入","aria-hidden":"true"}},[e._v("#")]),e._v(" Socket.IO 的引入")]),a("p",[e._v("Node.js上需要写一些程序，来处理TCP请求。")]),a("p",[e._v("Node.js从诞生之日起，就支持 WebSocket 协议。不过，从底层一步一步搭建一个Socket服务器很费劲（想象一下Node写一个静态文件服务都那么费劲）。所以，有大神帮我们写了一个库 Socket.IO。")]),a("p",[e._v("Socket.IO 是业界良心，新手福音。它屏蔽了所有底层细节，让顶层调用非常简单。并且还为不支持 WebSocket 协议的浏览器，提供了长轮询的透明模拟机制。")]),a("p",[e._v("Node的单线程、非阻塞I/O、事件驱动机制，使它非常适合Socket服务器。")]),a("h3",{attrs:{id:"socket-io-的安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socket-io-的安装","aria-hidden":"true"}},[e._v("#")]),e._v(" Socket.IO 的安装")]),a("p",[e._v("Socket.IO 的官网是："),a("a",{attrs:{href:"http://socket.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://socket.io/")])]),a("p",[e._v("安装方式：")]),a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\tnpm install socket.io\n")])])])}],!1,null,null,null);t.default=s.exports}}]);